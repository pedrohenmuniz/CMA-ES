/*
 * File:   TrussBarStructureStaticSimulator.h
 * Author: Heder S. Bernardino
 * Created on September 2, 2011, 08:36 AM
 *
 * ----------------------------------------------------------------------------
 *
 * This file was generated by conversion of the file stap942.f using
 * f2c -C++ stap942.f
 * To compile this, one can use the following command
 * cc *.o -lf2c -lm
 * ps.: Ubuntu users must use the commands
 * sudo mv /usr/lib/libf2c.so /usr/lib/libf2c.so.bkp
 * sudo ln -s /usr/lib/libf2c.a /usr/lib/libf2c.so
 * to avoid unnecessary errors
 */
#include <cmath>
#include <iostream>
#include <stdio.h>
#include <string.h>

// #include "../exception/EurekaOptimaException.h"
#include "EurekaOptimaException.h" //TODO: MODIFIED
#include "TrussBarStructureStaticSimulator.h"


using namespace exception;
using namespace std;


namespace truss_structure_simulator {

	TrussBarStructureStaticSimulator::TrussBarStructureStaticSimulator(double gamma, int numnp_cpp, int numeg_cpp, int nlcase_cpp, int modex_cpp, int* node_n_cpp, int** node_id_cpp, double** node_position_cpp, int* ll_cpp, int* loads_n_cpp, int** loads_node_cpp, int** loads_direction_cpp, double** loads_cpp, int elements_npar_1, int elements_npar_2, int elements_npar_3, int* element_id_cpp, double* element_cpp, double* element_extra_cpp, int* m_cpp, int* ii_cpp, int* jj_cpp, int* mtyp_cpp, int* kg_cpp): gamma(gamma), numnp_cpp(numnp_cpp), numeg_cpp(numeg_cpp), nlcase_cpp(nlcase_cpp), modex_cpp(modex_cpp), node_n_cpp(node_n_cpp), node_id_cpp(node_id_cpp), node_position_cpp(node_position_cpp), ll_cpp(ll_cpp), loads_n_cpp(loads_n_cpp), loads_node_cpp(loads_node_cpp), loads_direction_cpp(loads_direction_cpp), loads_cpp(loads_cpp), elements_npar_1(elements_npar_1), elements_npar_2(elements_npar_2), elements_npar_3(elements_npar_3), element_id_cpp(element_id_cpp), element_cpp(element_cpp), element_extra_cpp(element_extra_cpp), m_cpp(m_cpp), ii_cpp(ii_cpp), jj_cpp(jj_cpp), mtyp_cpp(mtyp_cpp), kg_cpp(kg_cpp) {

		this->memory = new double[ TrussBarStructureStaticSimulator::MEMORY_SPACE ];
		for (int i = 0; i < TrussBarStructureStaticSimulator::MEMORY_SPACE; i++) {
			this->memory[i] = 0.0;
		}
		this->npar = new int[10];
		for (int i = 0; i < 10; i++) {
			this->npar[i] = 0;
		}

		//replace read-write un1/ielmnt
		this->ielmnt_info1 = new int[ this->numeg_cpp ];
		this->ielmnt_info2 = new int[ this->numeg_cpp ];
		this->ielmnt = new double*[ this->numeg_cpp ]; //the number of doubles is the value in ielmnt_info1
		for(int i=0; i< this->numeg_cpp; i++) {
			this->ielmnt[i] = NULL;
		}
		//replace read-write un2/iload
		this->iload = new double*[ this->nlcase_cpp ];
		for(int i=0; i<this->nlcase_cpp; i++) {
			this->iload[i] = NULL;
		}
	}

	TrussBarStructureStaticSimulator::TrussBarStructureStaticSimulator(const TrussBarStructureStaticSimulator& orig): gamma(orig.gamma), numnp_cpp(orig.numnp_cpp), numeg_cpp(orig.numeg_cpp), nlcase_cpp(orig.nlcase_cpp), modex_cpp(orig.modex_cpp), node_n_cpp(orig.node_n_cpp), node_id_cpp(orig.node_id_cpp), node_position_cpp(orig.node_position_cpp), ll_cpp(orig.ll_cpp), loads_n_cpp(orig.loads_n_cpp), loads_node_cpp(orig.loads_node_cpp), loads_direction_cpp(orig.loads_direction_cpp), loads_cpp(orig.loads_cpp), elements_npar_1(orig.elements_npar_1), elements_npar_2(orig.elements_npar_2), elements_npar_3(orig.elements_npar_3), element_id_cpp(orig.element_id_cpp), element_cpp(orig.element_cpp), element_extra_cpp(orig.element_extra_cpp), m_cpp(orig.m_cpp), ii_cpp(orig.ii_cpp), jj_cpp(orig.jj_cpp), mtyp_cpp(orig.mtyp_cpp), kg_cpp(orig.kg_cpp) {

		this->memory = new double[TrussBarStructureStaticSimulator::MEMORY_SPACE];
		memcpy(this->memory, orig.memory, TrussBarStructureStaticSimulator::MEMORY_SPACE * sizeof (double));

		this->npar = new int[10];
		memcpy(this->npar, orig.npar, 10 * sizeof (int));

		//to include
//		int* ielmnt_info1;
//		int* ielmnt_info2;
//		double** ielmnt;
		//iload;
	}

	TrussBarStructureStaticSimulator::~TrussBarStructureStaticSimulator() {
		delete[] this->memory;
		delete[] this->npar;

		for(int i=0; i<this->numeg_cpp; i++) {
			delete[] this->ielmnt[i];
		}
		delete[] this->ielmnt;
		delete[] this->ielmnt_info1;
		delete[] this->ielmnt_info2;
		for(int i=0; i<this->nlcase_cpp; i++) {
			delete[] this->iload[i];
		}
		delete[] this->iload;
	}

	/* Method tensoes.
	 * It calculates (?) the tensions in the bars.
	 */
	int TrussBarStructureStaticSimulator::tensoes(double *tens1, double *tens2, double *tens3, int *l, double *tens) {
		int i__;

		/* Parameter adjustments */
		--tens;
		--tens3;
		--tens2;
		--tens1;

		/* Function Body */
		if (*l == 1) {
			for (i__ = 1; i__ <= this->elements_npar_2; ++i__) { //this loop used a fixed maximum i in stap
				tens1[i__] = tens[i__];
			}
		}

		if (*l == 2) {
			for (i__ = 1; i__ <= this->elements_npar_2; ++i__) { //this loop used a fixed maximum i in stap
				tens2[i__] = tens[i__];
			}
		}

		if (*l == 3) {
			for (i__ = 1; i__ <= this->elements_npar_2; ++i__) { //this loop used a fixed maximum i in stap
				tens3[i__] = tens[i__];
			}
		}

		return 0;
	} /* tensoes */

	/* Method desloc .
	 * It calculates (?) the displacements of the nodes.
	 */
	int TrussBarStructureStaticSimulator::desloc(double *d1, double *d2, double * d3, int *l, double *desl, int n_desloc_cpp) {
		int i__;

		/* Parameter adjustments */
		--desl;
		--d3;
		--d2;
		--d1;

		/* Function Body */
		if (*l == 1) {
			for (i__ = 1; i__ <= n_desloc_cpp; ++i__) { //this loop used a fixed maximum i in stap
				d1[i__] = desl[i__];
			}
		}

		if (*l == 2) {
			for (i__ = 1; i__ <= n_desloc_cpp; ++i__) { //this loop used a fixed maximum i in stap
				d2[i__] = desl[i__];
			}
		}

		if (*l == 3) {
			for (i__ = 1; i__ <= n_desloc_cpp; ++i__) { //this loop used a fixed maximum i in stap
				d3[i__] = desl[i__];
			}
		}

		return 0;
	} /* desloc */

	/* Method endarea.
	 * It set the values from "param" to "area" based on the groups.
	 */
	int TrussBarStructureStaticSimulator::endarea(double *area, int *nume, double * param) {

		for(int i=0; i< this->elements_npar_2; i++) {
			area[i] = param[i];
		}

		return 0;
	} /* endarea */

	/* Method colht.
	 */
	int TrussBarStructureStaticSimulator::colht(int *mht, int *nd, int *lm) {
		/* System generated locals */
		int i__1;

		/* Local variables */
		int i__;
		int ii;
		int me;
		int ls;

		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */
		/* .                                                                   . */
		/* .   P R O G R A M                                                   . */
		/* .        TO CALCULATE COLUMN HEIGHTS                                . */
		/* .                                                                   . */
		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */

		/* Parameter adjustments */
		--lm;
		--mht;

		/* Function Body */
		ls = 100000;            // <- what value is this ?
		i__1 = *nd;
		for (i__ = 1; i__ <= i__1; ++i__) {
			if (lm[i__] != 0) {
				if (lm[i__] - ls >= 0) {
					//do nothing
				} else {
					ls = lm[i__];
				}
			} else {
				//do nothing
			}
		}

		i__1 = *nd;
		for (i__ = 1; i__ <= i__1; ++i__) {
			ii = lm[i__];
			if (ii == 0) {
				//goto L200; //do nothing => modified to a "else"
			} else {
				me = ii - ls;
				if (me > mht[ii]) {
					mht[ii] = me;
				}
			}

		}

		return 0;
	} /* colht */

	/* Method addban.
	 */
	int TrussBarStructureStaticSimulator::addban(double *a, int *maxa, double *s, int *lm, int *nd) {
		/* System generated locals */
		int i__1;
		int i__2;

		/* Local variables */
		int i__;
		int j;
		int ii;
		int jj;
		int ij;
		int mi;
		int kk;
		int ks;
		int ndi;
		int kss;

		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */
		/* .                                                                   . */
		/* .   PROGRAM TO ASSEMBLE UPPER TRIANGULAR ELEMENT STIFFNESS INTO COMPACTED GLOBAL STIFFNESS . */
		/* .                                                                   . */
		/* .         A = GLOBAL STIFFNESS                                      . */
		/* .         S = ELEMENT STIFFNESS                                     . */
		/* .         ND = DEGREES OF FREEDOM IN ELEMENT STIFFNESS              . */
		/* .                                                                   . */
		/* .                   S(1)        S(2)        S(3)        . . .       . */
		/* .         S   =                 S(ND+1)     S(ND+2)     . . .       . */
		/* .                                           S(2*ND)     . . .       . */
		/* .                                                       . . .       . */
		/* .                                                                   . */
		/* .                                                                   . */
		/* .                   A(1)        A(3)        A(6)        . . .       . */
		/* .         A   =                 A(2)        A(5)        . . .       . */
		/* .                                           A(4)        . . .       . */
		/* .                                                       . . .       . */
		/* .                                                                   . */
		/* .                                                                   . */
		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */

		/* Parameter adjustments */
		--lm;
		--s;
		--maxa;
		--a;

		/* Function Body */
		ndi = 0;
		i__1 = *nd;
		for (i__ = 1; i__ <= i__1; ++i__) {
			ii = lm[i__];
			if (ii <= 0) {
				//do nothing
			} else {
				mi = maxa[ii];
				ks = i__;
				i__2 = *nd;
				for (j = 1; j <= i__2; ++j) {
					jj = lm[j];
					if (jj <= 0) {
						//do nothing
					} else {
						ij = ii - jj;
						if (ij >= 0) {
							kk = mi + ij;
							kss = ks;
							if (j >= i__) {
								kss = j + ndi;
							}
							a[kk] += s[kss];
						} else {
							//do nothing
						}
					}
					ks = ks + *nd - j;
				}
			}

			ndi = ndi + *nd - i__;
		}

		return 0;
	} /* addban */

	/* Method russ.
	 */
	int TrussBarStructureStaticSimulator::russ(int *id, double *x, double *y, double *z__, double *u, int *mht, double *e, double *area, int *lm, double *xyz, int *matp, double *tens, int *ncar) {

		/* System generated locals */
		int i__1;

		/* Local variables */
		double d__[3]; //this is used as a aux variable; 3 is the number of dimensions
		int i__;
		int j;
		int k;
		int l;
		int m;
		int n;
		double p;
		double s[21]; // 21 looks to be a magic number
		int nd;
		int ii;
		int jj;
		int kg;
		int kl;
		double xl;
		double st[6]; // 6 looks to be a magic number; to verify if this value is related with the 6 used in the following
		double xx;
		double yy;
		double xl2;
		int kkk;
		double str;

		int* nume = (int *) &npar[1];
		int* nummat = (int *) &npar[2];
		int mtyp;
		int mtype;

		/* Parameter adjustments */
		--tens;
		--matp;
		xyz -= 7;
		lm -= 7;
		--area;
		--e;
		--mht;
		--u;
		--z__;
		--y;
		--x;
		id -= 4;

		/* Function Body */
		nd = 6;

		bool goto_l100_first = true;

		//because of a write function removed
		int i_cpp = 0;
		int j_cpp = 0;

		switch (ind) {
			case 1:

				/*     R E A D   A N D   G E N E R A T E   E L E M E N T   I N F O R M A T I O N */

				/*     READ MATERIAL INFORMATION */

				if (*nummat == 0) {
					*nummat = 1;
				}

				i__1 = *nummat;
				for (i__ = 1; i__ <= i__1; ++i__) {
					n = this->element_id_cpp[i_cpp];
					e[n] = this->element_cpp[i_cpp];
					//variable "this->element_extra_cpp" was not used by stap
					//because of a write function removed
					i_cpp++;
				}

				/*     READ ELEMENT INFORMATION */

				n = 1;


				do {
					//do-while created by remotion of the goto L100 and L120

					if (goto_l100_first || n > m) {
						goto_l100_first = false;
						m = this->m_cpp[j_cpp];
						ii = this->ii_cpp[j_cpp];
						jj = this->jj_cpp[j_cpp];
						mtyp = this->mtyp_cpp[j_cpp];
						kg = this->kg_cpp[j_cpp];
						if (kg == 0) {
							kg = 1;
						}

						//because of a write function removed
						j_cpp++;
					}

					if (m != n) {
						//do nothing
					} else {
						//else created because of the remotion of the goto L200
						i__ = ii;
						j = jj;
						mtype = mtyp;
						kkk = kg;
					}

					/*     SAVE ELEMENT INFORMATION */
					xyz[n * 6 + 1] = x[i__];
					xyz[n * 6 + 2] = y[i__];
					xyz[n * 6 + 3] = z__[i__];

					xyz[n * 6 + 4] = x[j];
					xyz[n * 6 + 5] = y[j];
					xyz[n * 6 + 6] = z__[j];

					matp[n] = mtype;

					for (l = 1; l <= 6; ++l) {
						lm[l + n * 6] = 0;
					}
					for (l = 1; l <= 3; ++l) {
						lm[l + n * 6] = id[l + i__ * 3];
						lm[l + 3 + n * 6] = id[l + j * 3];
					}

					/*     UPDATE COLUMN HEIGHTS AND BANDWIDTH */

					colht(&mht[1], &nd, &lm[n * 6 + 1]);

					if (n == *nume) {
						return 0;
					}
					++n;
					i__ += kkk;
					j += kkk;
				} while (true);


			case 2:

				/*     A S S E M B L E  S T U C T U R E  S T I F F N E S S  M A T R I X */

				i__1 = *nume;
				for (n = 1; n <= i__1; ++n) {
					mtype = matp[n];
					xl2 = 0.f;
					for (l = 1; l <= 3; ++l) {
						d__[l - 1] = xyz[l + n * 6] - xyz[l + 3 + n * 6];
						xl2 += d__[l - 1] * d__[l - 1];
					}
					xl = sqrt(xl2);
					xx = e[mtype] * area[mtype] * xl;
					for (l = 1; l <= 3; ++l) {
						st[l - 1] = d__[l - 1] / xl2;
						st[l + 2] = -st[l - 1];
					}

					kl = 0;
					for (l = 1; l <= 6; ++l) {
						yy = st[l - 1] * xx;
						for (k = l; k <= 6; ++k) {
							++kl;
							s[kl - 1] = st[k - 1] * yy;
						}
					}

					addban(&memory[n3 - 1], (int*) &memory[n2 - 1], s, &lm[n * 6 + 1], &nd);

				}
				return 0;

			case 3:
				/*     S T R E S S  C A L C U L A T I O N S */
				i__1 = *nume;
				for (n = 1; n <= i__1; ++n) {
					mtype = matp[n];
					xl2 = 0.f;
					for (l = 1; l <= 3; ++l) {
						d__[l - 1] = xyz[l + n * 6] - xyz[l + 3 + n * 6];
						xl2 += d__[l - 1] * d__[l - 1];
					}
					for (l = 1; l <= 3; ++l) {
						st[l - 1] = d__[l - 1] / xl2 * e[mtype];
						st[l + 2] = -st[l - 1];
					}
					str = 0.f;
					for (l = 1; l <= 3; ++l) {
						i__ = lm[l + n * 6];
						if (i__ <= 0) {
							//do nothing
						} else {
							//else created because of the remotion of the goto L806
							str += st[l - 1] * u[i__];
						}
						j = lm[l + 3 + n * 6];
						if (j <= 0) {
							//do nothing
						} else {
							//else created because of the remotion of the goto L806
							str += st[l + 2] * u[j];
						}

					}
					p = str * area[mtype];

					tens[n] = str;

				}

				return 0;

		} //switch-end



	} /* russ */

	/* Method error.
	 */
	int TrussBarStructureStaticSimulator::error(int *n, int *i__) {

		return 0;
	} /* error */

	/* Method truss.
	 */
	int TrussBarStructureStaticSimulator::truss(double *param, int *ncar) {
		/* System generated locals */
		int i__1;

		/* Local variables */
		int* nume = (int *) &npar[1];
		int* nummat = (int *) &npar[2];

		/* Parameter adjustments */
		--param;

		/* Function Body */
		nfirst = n6;
		if (ind > 1) {
			nfirst = n5;
		}
		n101 = nfirst;
		n102 = n101 + *nummat * itwo;
		n103 = n102 + *nummat * itwo;
		n104 = n103 + *nume * 6;		// where does this value (6) come from? A magic number ?
		n105 = n104 + *nume * 6 * itwo; // where does this value (6) come from? A magic number ?
		n106 = n105 + *nume;
		n107 = n106 + *nume * itwo;
		nlast = n107;

		if (ind > 1) {
			if (nlast > mtot) {
				i__1 = nlast - mtot;
				//error(&i__1, &c__4);
			}
		} else {
			//else created by remotion of the goto L100
			if (nlast > mtot) {
				i__1 = nlast - mtot;
				//error(&i__1, &c__3);
			}

		}

		midest = nlast - nfirst;

		/*     ATUALIZA AREAS PARA MONTAGEM DA MATRIZ DE RIGIDEZ */

		if (ind != 1) {
			//conversoes desnecessarias (double*) e (int*)
			endarea(&memory[n102 - 1], nume, &param[1]);
		}

		//conversoes desnecessarias (double*) e (int*)
		russ(
				(int*) &memory[n1 - 1],
				&memory[n2 - 1],
				&memory[n3 - 1],
				&memory[n4 - 1],
				&memory[n4 - 1],
				(int*) &memory[n5 - 1],
				&memory[n101 - 1],
				&memory[n102 - 1],
				(int*) &memory[n103 - 1],
				&memory[n104 - 1],
				(int*) &memory[n105 - 1],
				&memory[n106 - 1],
				ncar);

		return 0;

	} /* truss */

	/* Method elemnt.
	 */
	int TrussBarStructureStaticSimulator::elemnt(double *param, int *ncar) {
		int npar1;

		/* Parameter adjustments */
		--param;

		/* Function Body */
		npar1 = npar[0];

		/*     OTHER ELEMENT TYPES WOULD BE CALLED HERE, IDENTIFYING EACH */
		/*     ELEMENT TYPE BY A DIFFERENT NPAR(1) PARAMETER */

		switch (npar1) {
			case 1:
				truss(&param[1], ncar);
				break;
			case 2:
				break;
			case 3:
				break;
		}

		return 0;
	} /* elemnt */

	/* Method stress.
	 */
	int TrussBarStructureStaticSimulator::stress(double *aa, double *param, int *ncar) {
		/* System generated locals */
		int i__1;
		int i__2;

		/* Local variables */
		int i__;
		int n;
		int numest;

		/*     LOOP OVER ALL ELEMENT GROUPS */

		/* Parameter adjustments */
		--param;
		--aa;

		i__1 = numeg;
		for (n = 1; n <= i__1; ++n) {
			ng = n;

			numest = this->ielmnt_info1[n-1];
			npar[0] = this->ielmnt_info2[n-1];

			i__2 = numest;
			for (i__ = 1; i__ <= i__2; ++i__) {
				aa[i__] = this->ielmnt[n-1][i__-1];
			}

			elemnt(&param[1], ncar);

			/* L100: */
		}

		return 0;
	} /* stress */

	/* Method writed.
	 */
	int TrussBarStructureStaticSimulator::writed(double *disp, int *id, int *neq, int *numnp) {
		/* System generated locals */
		int i__1;

		/* Local variables */
		double d__[3];
		int i__;
		int ic;
		int ii;
		int il;
		int kk;

		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */
		/* .                                                                   . */
		/* .   PROGRAM TO PRINT DISPLACEMENTS                                  . */
		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */

		/* Parameter adjustments */
		--disp;
		id -= 4;				// where does this value (4) come from? A magic number ? Is this used in the follow?

		/* Function Body */
		ic = 4;					// where does this value (4) come from? A magic number ? Is this used in the follow?

		i__1 = *numnp;
		for (ii = 1; ii <= i__1; ++ii) {
			++ic;
			if (ic < 56) {        // where does this value (56) come from? A magic number ?
				//do nothing
			} else {
				//else created by remotion of the goto L105
				ic = 4;			// where does this value (4) come from? A magic number ?
			}

			for (i__ = 1; i__ <= 3; ++i__) {
				d__[i__ - 1] = 0.f;
			}

			for (i__ = 1; i__ <= 3; ++i__) {
				kk = id[i__ + ii * 3];
				il = i__;
				if (kk != 0) {
					d__[il - 1] = disp[kk];
				}
			}

		}

		return 0;

	} /* writed */

	/* Method loadv.
	 */
	int TrussBarStructureStaticSimulator::loadv(double *r__, int *neq) {
		/* System generated locals */
		int r_dim1;

		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */
		/* .                                                                   . */
		/* .   PROGRAM TO OBTAIN THE LOAD VECTOR                               . */
		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */

		/* Parameter adjustments */
		r_dim1 = *neq;

		for(int i=0; i<r_dim1; i++) {
			r__[i] = this->iload[this->i_iload][i];
		}

		return 0;
	} /* loadv */

	/* Method colsol.
	 */
	int TrussBarStructureStaticSimulator::colsol(double *a, double *v, int *maxa, int *nn, int *nwk, int *nnm, int *kkk) {

		/* System generated locals */
		int i__1;
		int i__2;
		int i__3;

		/* Local variables */
		double b;
		double c__;
		int j;
		int k;
		int l;
		int n;
		int ic;
		int nd;
		int kh;
		int ki;
		int kk;
		int kl;
		int kn;
		int ku;
		int klt;

		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */
		/* .                                                                   . */
		/* .   P R O G R A M                                                   . */
		/* .        TO SOLVE FINITE ELEMENT STATIC EQUILIBRIUM EQUATIONS IN    . */
		/* .        CORE, USING COMPACTED STORAGE AND COLUMN REDUCTION SCHEME  . */
		/* .                                                                   . */
		/* .  - - INPUT VARIABLES - -                                          . */
		/* .        A(NWK)    = STIFFNESS MATRIX STORED IN COMPACTED FORM      . */
		/* .        V(NN)     = RIGHT-HAND-SIDE LOAD VECTOR                    . */
		/* .        MAXA(NNM) = VECTOR CONTAINING ADDRESSES OF DIAGONAL        . */
		/* .                    ELEMENTS OF STIFFNESS MATRIX IN A              . */
		/* .        NN        = NUMBER OF EQUATIONS                            . */
		/* .        NWK       = NUMBER OF ELEMENTS BELOW SKYLINE OF MATRIX     . */
		/* .        NNM       = NN + 1                                         . */
		/* .        KKK       = INPUT FLAG                                     . */
		/* .            EQ. 1   TRIANGULARIZATION OF STIFFNESS MATRIX          . */
		/* .            EQ. 2   REDUCTION AND BACK-SUBSTITUTION OF LOAD VECTOR . */
		/* .                                                                   . */
		/* .  - - OUTPUT - -                                                   . */
		/* .        A(NWK)    = D AND L - FACTORS OF STIFFNESS MATRIX          . */
		/* .        V(NN)     = DISPLACEMENT VECTOR                            . */
		/* .                                                                   . */
		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */

		/*     PERFORM L*D*L(T) FACTORIZATION OF STIFFNESS MATRIX */

		/* Parameter adjustments */
		--v;
		--maxa;
		--a;

		/* Function Body */
		if (*kkk - 2 >= 0) {
			/*     REDUCE RIGHT-HAND-SIDE LOAD VECTOR */
			i__1 = *nn;
			for (n = 1; n <= i__1; ++n) {
				kl = maxa[n] + 1;
				ku = maxa[n + 1] - 1;
				if (ku - kl >= 0) {
					k = n;
					c__ = 0.f;
					i__2 = ku;
					for (kk = kl; kk <= i__2; ++kk) {
						--k;
						c__ += a[kk] * v[k];
					}
					v[n] -= c__;
				} else {
					//do nothing
				}

			}

			/*     BACK-SUBSTITUTE */

			i__1 = *nn;
			for (n = 1; n <= i__1; ++n) {
				k = maxa[n];
				v[n] /= a[k];
			}
			if (*nn == 1) {
				return 0;
			}
			n = *nn;
			i__1 = *nn;
			for (l = 2; l <= i__1; ++l) {
				kl = maxa[n] + 1;
				ku = maxa[n + 1] - 1;
				if (ku - kl >= 0) {
					k = n;
					i__2 = ku;
					for (kk = kl; kk <= i__2; ++kk) {
						--k;
						v[k] -= a[kk] * v[n];
					}
				} else {
					//do nothing
				}

				--n;
			}
			return 0;

		} else {

			i__1 = *nn;
			for (n = 1; n <= i__1; ++n) {
				kn = maxa[n];
				kl = kn + 1;
				ku = maxa[n + 1] - 1;
				kh = ku - kl;
				if (kh < 0) {
					//do nothing
				} else {
					if (kh == 0) {
						//do nothing
					} else {
						k = n - kh;
						ic = 0;
						klt = ku;
						i__2 = kh;
						for (j = 1; j <= i__2; ++j) {
							++ic;
							--klt;
							ki = maxa[k];
							nd = maxa[k + 1] - ki - 1;
							if (nd <= 0) {
								//do nothing
							} else {
								kk = min(ic, nd);
								c__ = 0.f;
								i__3 = kk;
								for (l = 1; l <= i__3; ++l) {
									c__ += a[ki + l] * a[klt + l];
								}
								a[klt] -= c__;
							}

							++k;
						}
					}

					k = n;
					b = 0.f;
					i__2 = ku;
					for (kk = kl; kk <= i__2; ++kk) {
						--k;
						ki = maxa[k];
						c__ = a[kk] / a[ki];
						b += c__ * a[kk];
						a[kk] = c__;
					}
					a[kn] -= b;

				}

				if (a[kn] <= 0.) {
//					printf("STOP - Stiffness matrix not positive definite - Non-positive pivot.\n");
					throw EurekaOptimaException( "Stiffness matrix not positive definite - Non-positive pivot." );

					return 0;
				} else {
					//do nothing
				}

			}
			return 0;

		}

	} /* colsol */

	/* Method assem.
	 */
	int TrussBarStructureStaticSimulator::assem(double *aa, double *param, int *ncar) {
		/* System generated locals */
		int i__1;
		int i__2;

		/* Local variables */
		int i__;
		int n;
		int numest;

		/* Parameter adjustments */
		--param;
		--aa;

		i__1 = numeg;
		for (n = 1; n <= i__1; ++n) {
			numest = this->ielmnt_info1[n-1];
			npar[0] = this->ielmnt_info2[n-1];
			i__2 = numest;
			for (i__ = 1; i__ <= i__2; ++i__) {
				aa[i__] = this->ielmnt[n-1][i__-1];
			}

			elemnt(&param[1], ncar);

			/* L200: */
		}

		return 0;
	} /* assem */

	/* Method clear.
	 */
	int TrussBarStructureStaticSimulator::clear(double *a, int *n) {
		/* System generated locals */
		int i__1;

		/* Local variables */
		int i__;

		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */
		/* .                                                                   . */
		/* .   PROGRAM TO CLEAR ARRAY                                          . */
		/* .                                                                   . */
		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */
		/* Parameter adjustments */
		--a;

		/* Function Body */
		i__1 = *n;
		for (i__ = 1; i__ <= i__1; ++i__) {
			//cout << i__ << endl;
			a[i__] = 0.f;
		}
		return 0;
	} /* clear */

	/* Method addres.
	 */
	int TrussBarStructureStaticSimulator::addres(int *maxa, int *mht) {
		/* System generated locals */
		int i__1;

		/* Local variables */
		int i__;
		int nn;

		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */
		/* .                                                                   . */
		/* .   PROGRAM TO CALCULATE ADDRESSES OF DIAGONAL ELEMENTS IN BANDED   . */
		/* .        MATRIX WHOSE COLUMN HEIGHTS ARE KNOWN                      . */
		/* .                                                                   . */
		/* .        MHT  = ACTIVE COLUMN HEIGHTS                               . */
		/* .         MAXA = ADDRESSES OF DIAGONAL ELEMENTS                      . */
		/* .                                                                   . */
		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */

		/*     CLEAR ARRAY MAXA */

		/* Parameter adjustments */
		--mht;
		--maxa;

		/* Function Body */
		nn = neq + 1;
		i__1 = nn;
		for (i__ = 1; i__ <= i__1; ++i__) {
			maxa[i__] = 0.f;
		}

		maxa[1] = 1;
		maxa[2] = 2;
		mk = 0;
		if (neq == 1) {
			//do nothing
		} else {
			//else included because of the remotion of the goto L100

			i__1 = neq;
			for (i__ = 2; i__ <= i__1; ++i__) {
				if (mht[i__] > mk) {
					mk = mht[i__];
					//cout << "mht[" << i__ << "] = " << mk << endl;
				}
				maxa[i__ + 1] = maxa[i__] + mht[i__] + 1;
				//cout << "maxa[" << i__ + 1 << "] = " << maxa[i__ + 1] << endl;
			}
		}

		++mk;
		nwk = maxa[neq + 1] - maxa[1];

		return 0;
	} /* addres */

	/* Method elcal.
	 */
	int TrussBarStructureStaticSimulator::elcal(double *param, int *ncar) {

		/* System generated locals */
		int i__1;
		int i__2;

		/* Local variables */
		int i__;
		int n;

		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */
		/* .                                                                   . */
		/* . PROGRAM TO LOOP OVER ALL ELEMENT GROUPS FOR READING, GENERATING AND STORING THE ELEMENT DATA. */
		/* .                                                                   . */
		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */

		/* Parameter adjustments */
		--param;

		/*     LOOP OVER ALL ELEMENT GROUPS */

		i__1 = numeg;
		for (n = 1; n <= i__1; ++n) {

			npar[0] = this->elements_npar_1;
			npar[1] = this->elements_npar_2;
			npar[2] = this->elements_npar_3;

			elemnt(&param[1], ncar);

			if (midest > maxest) {
				maxest = midest;
			}

			this->ielmnt_info1[n-1] = midest;
			this->ielmnt_info2[n-1] = npar[0];
			//it is necessary because this method is called several times - to try improved it
			if (this->ielmnt[n-1]!=NULL) {
				delete[] this->ielmnt[n-1];
			}
			this->ielmnt[n-1] = new double[ midest + 1 ];

			i__2 = nlast;
			for (i__ = nfirst; i__ <= i__2; ++i__) {
				this->ielmnt[n-1][i__-nfirst] = memory[i__ - 1];
			}

		}

		return 0;

	} /* elcal */

	/* Method loads.
	 */
	int TrussBarStructureStaticSimulator::loads(double *r__, int *nod, int *idirn, double *fload, int *id, int *nload, int *neq, int loadCase) {

		/* System generated locals */
		int r_dim1;
		int i__1;

		/* Local variables */
		int i__;
		int l;
		int ii;
		int li;
		int ln;

		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */
		/* .                                                                   . */
		/* .   PROGRAM TO READ NODAL LOAD DATA TO CALCULATE THE LOAD VECTOR R FOR EACH LOAD CASE AND WRITE ONTO UNIT ILOAD. */
		/* .                                                                   . */
		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */

		/* Parameter adjustments */
		--nod;
		--idirn;
		--fload;
		id -= 4;
		r_dim1 = *neq;
		--r__;

		//because of a write function removed
		int i = 0;

		i__1 = *nload;
		for (i__ = 1; i__ <= i__1; ++i__) {
			nod[i__] = this->loads_node_cpp[loadCase][i];
			idirn[i__] = this->loads_direction_cpp[loadCase][i];
			fload[i__] = this->loads_cpp[loadCase][i];

			//because of a write function removed
			i++;
		}
		if (modex == 0) {
			return 0;
		}

		i__1 = *neq;
		for (i__ = 1; i__ <= i__1; ++i__) {
			r__[i__] = 0.f;
		}

		i__1 = *nload;
		for (l = 1; l <= i__1; ++l) {
			ln = nod[l];
			li = idirn[l];
			ii = id[li + ln * 3];
			if (ii <= 0) {
				//do nothing
			} else {
				r__[ii] += fload[l];
			}

		}

		if (this->iload[this->i_iload]==NULL) {
			this->iload[this->i_iload] = new double[r_dim1];
		}
		for (int i = 0; i < r_dim1; i++) {
			double g = r__[i+1];
			this->iload[this->i_iload][i] = r__[i+1];   //i+1 because the instruction '--r__' can not be removed yet
		}

		return 0;

	} /* loads */

	/* Method input.
	 */
	int TrussBarStructureStaticSimulator::input(int *id, double *x, double *y, double *z__, int *numnp, int *neq) {

		/* System generated locals */
		int i__1;

		/* Local variables */
		int i__;
		int j;
		int k;
		int n;
		int kk;
		int kn;
		double dx;
		int dy;
		int dz;
		int num;
		int nold;
		int numn;
		double xnum;
		int knold;

		/* Parameter adjustments */
		--x;
		--y;
		--z__;
		id -= 4;			// where does this value (4) come from? A magic number ?

		//because of a write function removed
		int i = 0;

		/* Function Body */
		do {
			//do-while created because of the remotion of the goto L50

			n = this->node_n_cpp[i];
			for (i__ = 1; i__ <= 3; ++i__) {
				id[i__ + n * 3] = this->node_id_cpp[i][i__-1];
			}
			x[n] = this->node_position_cpp[i][0];
			y[n] = this->node_position_cpp[i][1];
			z__[n] = this->node_position_cpp[i][2];

			knold = 0;
			nold = 0;

			if (knold == 0) {
				//do nothing
			} else {
				//else included because of the remotion of the goto L50
				num = (n - nold) / knold;
				numn = num - 1;
				if (numn < 1) {
					//do nothing
				} else {
					//else included because of the remotion of the goto L50
					xnum = (double) num;
					dx = (x[n] - x[nold]) / xnum;
					dy = (y[n] - y[nold]) / xnum;
					dz = (z__[n] - z__[nold]) / xnum;
					k = nold;
					i__1 = numn;
					for (j = 1; j <= i__1; ++j) {
						kk = k;
						k += knold;
						x[k] = x[kk] + dx;
						y[k] = y[kk] + dy;
						z__[k] = z__[kk] + dz;
						for (i__ = 1; i__ <= 3; ++i__) {
							id[i__ + k * 3] = id[i__ + kk * 3];
							/* L30: */
						}
					}
				}
			}

			nold = n;
			knold = kn;
			//because of a write function removed
			i++;
		} while (n != *numnp);

		/*     NUMBER UNKNOWNS */

		*neq = 0;
		i__1 = *numnp;
		for (n = 1; n <= i__1; ++n) {
			for (i__ = 1; i__ <= 3; ++i__) {
				if (id[i__ + n * 3] != 0) {
					id[i__ + n * 3] = 0;
				} else {
					++(*neq);
					id[i__ + n * 3] = *neq;
				}

			}
		}

		return 0;

	} /* input */

	/* Method calcfobj.
	 */
	int TrussBarStructureStaticSimulator::calcfobj(double *u, double *tens, double *xyz, double *area, int *nume, double *param, double *fobj, double *v, double *d1, double * d2, double *d3, double *tens1, double *tens2, double * tens3, int n_constraints_cpp, int nlcase) {

		/* Local variables */
		int i__;
		int j;
		int l;
		int n;

		double distance;
		double temp;

		/* Parameter adjustments */
		--u;
		--tens;
		xyz -= 7;
		--area;
		--param;
		--v;
		--d1;
		--d2;
		--d3;
		--tens1;
		--tens2;
		--tens3;

		//weight of the structure - objective function
		*fobj = 0.0;
		*nume = this->elements_npar_2; //this used a fixed value in stap
		for (n = 1; n <= this->elements_npar_2; ++n) {
			distance = 0;
			for (l = 1; l <= 3; ++l) {
				temp = xyz[l + n * 6] - xyz[l + 3 + n * 6];
				distance += temp*temp;
			}
			//weight of each bar = distance between two nodes * area of the bar * density
			*fobj += sqrt( distance ) * area[n] * this->gamma;
		}

		// constraints

		//normal stresses
		int i = 1;
		for (j = 1; j <= this->elements_npar_2; ++j) {
			//temp = tens1[j] / this->stressConstraint;
			//v[j] = abs(temp) - 1;
			v[j] = tens1[i];
			i++;
		}

		//this code must be improved
		if (nlcase>1) {
			i = 1;
			for (; j <= 2*this->elements_npar_2; ++j) {
				v[j] = tens2[i];
				i++;
			}
			if (nlcase>2) {
				i = 1;
				for (; j <= 3*this->elements_npar_2; ++j) {
					v[j] = tens3[i];
					i++;
				}
			}
		}
		//end of the code which must be improved

		//displacements
		//for (i__ = this->elements_npar_2+1; i__ <= this->elements_npar_2+this->numberOfDisplacements; ++i__) {
		i = 1;
		for (i__ = 1; i__ <= n_constraints_cpp; ++i__) {
			//temp = d1[i__] / this->displacementConstraint;
			//v[this->elements_npar_2+i__] = abs(temp) - 1;
			//v[this->elements_npar_2+i__] = d1[i__];
			v[nlcase*this->elements_npar_2+i__] = d1[i]; //modified because of the 'nlcases'
			i++;
		}

		//this code must be improved
		if (nlcase>1) {
			i = 1;
			for (; i__ <= 2*n_constraints_cpp; ++i__) {
				v[nlcase*this->elements_npar_2+i__] = d2[i];
				i++;
			}
			if (nlcase>2) {
				i = 1;
				for (; i__ <= 3*n_constraints_cpp; ++i__) {
					v[nlcase*this->elements_npar_2+i__] = d3[i];
					i++;
				}
			}
		}

		//end of the code which must be improved

		return 0;
	} /* calcfobj */

	/* Method stap.
	 */
	double TrussBarStructureStaticSimulator::stap(double *param, double *fobj, double *v) {

		/* System generated locals */
		int i__1;
		int i__2;
		double ret_val;

		/* Local variables */
		int i__;
		int l;
		int ll;
		int mm;
		int nnl;
		int ktr;
		int neq1;
		int ncar;
		int nume;
		int nload;
		int nlcase;

		//variables with the stresses
		//The 3 arrays represents the maximum number of loads allowed -- to improve
		double* tens1 = new double[this->elements_npar_2]; // the length was fixed in stap
		double* tens2 = new double[this->elements_npar_2];
		double* tens3 = new double[this->elements_npar_2];




		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */
		/* .   THE FOLLOWING TWO LINES ARE USED TO DETERMINE THE MAXIMUM HIGH  . */
		/* .   SPEED STORAGE THAT CAN BE USED FOR SOLUTION. TO CHANGE THE HIGH . */
		/* .   SPEED STORAGE AVAILABLE FOR EXECUTION, CHANGE THE VALUE OF MTOT . */
		/* .   AND CORRESPONDINGLY COMMON A(MTOT).                             . */
		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */
		/* Parameter adjustments */
		--v;
		--param;

		/* Function Body */
		mtot = 1000000; // candidate to be removed
		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */
		/* .   DOUBLE PRECISION LINE                                           . */
		/* .     ITWO = 1 SINGLE PRECISION ARITHMETIC                          . */
		/* .     ITWO = 2 DOUBLE PRECISION ARITHMETIC                          . */
		/* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */
		itwo = 2; // candidate to be removed

		/*     THE FOLLOWING SCRATCH FILES ARE USED */
		/*        IELMNT = UNIT STORING ELEMENT DATA */
		/*        ILOAD  = UNIT STORING LOAD VECTORS */
		/*        IIN    = UNIT USED FOR INPUT */

		/*     ON SOME MACHINES THESE FILES MUST BE EXPLICITLY OPENED */

		/* L200: */
		numest = 0;
		maxest = 0;

		//new input code -- must be improved
		this->numnp = this->numnp_cpp;
		this->numeg = this->numeg_cpp;
		nlcase = this->nlcase_cpp;
		this->modex = this->modex_cpp;

		if (numnp == 0) {
			return ret_val;
		}

		/*     R E A D   N O D A L   P O I N T   D A T A */

		n1 = 1;
		n2 = n1 + numnp * 3;
		n2 = (n2 / 2 << 1) + 1;
		n3 = n2 + numnp * itwo;
		n4 = n3 + numnp * itwo;
		n5 = n4 + numnp * itwo;
		if (n5 > mtot) {
			i__1 = n5 - mtot;
			//error(&i__1, &c__1);
		}

		//unnecessary conversions (int*), (double*)
		input(
				(int*) &memory[n1 - 1],
				&memory[n2 - 1],
				&memory[n3 - 1],
				&memory[n4 - 1],
				&numnp,
				&neq
				);

		neq1 = neq + 1;

		//definition of the displacements
		//each 'd' represents each load case (maximum of 3)
		double* d1 = new double[neq]; //include as a way to fix the number of displacement
		double* d2 = new double[neq]; //include as a way to fix the number of displacement
		double* d3 = new double[neq]; //include as a way to fix the number of displacement

		/*     C A L C U L A T E   A N D   S T O R E   L O A D   V E C T O R S */

		n6 = n5 + neq * itwo;

		this->i_iload = 0;

		i__1 = nlcase;
		for (l = 1; l <= i__1; ++l) {

			ll = this->ll_cpp[l-1];
			nload = this->loads_n_cpp[l-1];

			if (ll == l) {
				//do nothing
			} else {
				return ret_val;
			}

			n7 = n6 + nload;
			n8 = n7 + nload;
			n9 = n8 + nload * itwo;

			if (n9 > mtot) {
				i__2 = n9 - mtot;
				//error(&i__2, &c__2);
			}

			//unnecessary conversions: (double*), (int*)
			loads(
					&memory[n5 - 1],
					(int*) &memory[n6 - 1],
					(int*) &memory[n7 - 1],
					&memory[n8 - 1],
					(int*) &memory[n1 - 1],
					&nload,
					&neq,
					l-1   // the '-1' is to correct the id -- to be improved
					);


			this->i_iload++;

		}

		/*     R E A D , G E N E R A T E   A N D   S T O R E */
		/*     E L E M E N T   D A T A */

		/*     CLEAR STORAGE */

		n6 = n5 + neq;
		n6 = (n6 / 2 << 1) + 1;
		i__1 = n6;
		for (i__ = n5; i__ <= i__1; ++i__) {
			memory[i__ - 1] = 0;
		}
		ind = 1;

		ncar = 0;

		elcal(&param[1], &ncar);

		/*     * * * * * * * * * * * * * * * * * * * * * * */

		/*     * * *   S O L U T I O N   P H A S E   * * * */

		/*     * * * * * * * * * * * * * * * * * * * * * * */

		/*     A S S E M B L E   S T I F F N E S S   M A T R I X */


		//unnecessary conversions: (int*)
		addres(
				(int*) &memory[n2 - 1],
				(int*) &memory[n5 - 1]
				);

		mm = nwk / neq;
		n3 = n2 + neq + 1;
		n3 = (n3 / 2 << 1) + 1;
		n4 = n3 + nwk * itwo;
		n5 = n4 + neq * itwo;
		n6 = n5 + maxest;
		if (n6 > mtot) {
			i__1 = n6 - mtot;
			//error(&i__1, &c__4);
		}

		/*     IN DATA CHECK ONLY MODE WE SKIP ALL FURTHER CALCULATIONS */

		if (modex > 0) {


			try {

				/*     CLEAR STORAGE */

				nnl = nwk + neq;

				//unnecessary conversion: (double*)
				clear(
						&memory[n3 - 1],
						&nnl
						);

				ind = 2; // magic number ?

				assem(&memory[n5 - 1], &param[1], &ncar);

				/*     T R I A N G U L A R I Z E   S T I F F N E S S   M A T R I X */


				ktr = 1; // magic number ?

				//unnecessary conversions: (double*), (int*).
				colsol(
						&memory[n3 - 1],
						&memory[n4 - 1],
						(int*) &memory[n2 - 1],
						&neq,
						&nwk,
						&neq1,
						&ktr
						);

				ktr = 2; // magic number ?
				ind = 3; // magic number ?

				this->i_iload = 0;
				i__1 = nlcase;
				for (l = 1; l <= i__1; ++l) {

					ncar = l;

					//unnecessary conversion (double*).
					loadv(
							&memory[n4 - 1],
							&neq
							);


					/*     C A L C U L A T I O N   O F   D I S P L A C E M E N T S */


					//unnecessary conversions: (double*), (int*)
					colsol(
							&memory[n3 - 1],
							&memory[n4 - 1],
							(int*) &memory[n2 - 1],
							&neq,
							&nwk,
							&neq1,
							&ktr
							);

					//unnecessary conversion (double*)
					desloc(
							d1,
							d2,
							d3,
							&l,
							&memory[n4 - 1],
							neq   //include as a way to fix the number of displacements
							);

					//unnecessary conversions: (double*), (int*)
					writed(
							&memory[n4 - 1],
							(int*) &memory[n1 - 1],
							&neq,
							&numnp
							);

					/*     C A L C U L A T I O N   O F   S T R E S S E S */

					stress(
							&memory[n5 - 1],
							&param[1],
							&ncar
							);

					//unnecessary conversion (double*)
					tensoes(
							tens1,
							tens2,
							tens3,
							&l,
							&memory[n106 - 1]
							);

					this->i_iload++;

				}

				/* ********************************************************* */
				/*         CALCULA FUNcaoO OBJETIVO E RESTRIcoES */
				/* ********************************************************* */

				//unnecessary conversions (double*)
				calcfobj(
						&memory[n4 - 1],
						&memory[n106 - 1],
						&memory[n104 - 1],
						&memory[n102 - 1],
						&nume,
						&param[1],
						fobj,
						&v[1],
						d1,
						d2,
						d3,
						tens1,
						tens2,
						tens3,
						neq,   //include as a way to fix the number of displacements
						nlcase
						);

			} catch ( EurekaOptimaException ex ) {

				delete[] d1;
				delete[] d2;
				delete[] d3;
				delete[] tens1;
				delete[] tens2;
				delete[] tens3;

				throw new EurekaOptimaException( ex.what() );
				// because of a possible exception in the colsol method
				// caused by a stiffness matrix not positive definite
				// Non-positive pivot.

			}

		} //end-if

		/*     READ NEXT ANALYSIS CASE */

		/*	printf("n1 = %d\n", n1);
			printf("n2 = %d\n", n2);
			printf("n3 = %d\n", n3);
			printf("n4 = %d\n", n4);
			printf("n5 = %d\n", n5);
			printf("n6 = %d\n", n6);
			printf("n7 = %d\n", n7);
			printf("n8 = %d\n", n8);
			printf("n9 = %d\n", n9);
			printf("n10 = %d\n", n10);
			printf("n11 = %d\n", n11);
			printf("n12 = %d\n", n12);
			printf("n13 = %d\n", n13);
			printf("n14 = %d\n", n14);
			printf("n15 = %d\n", n15);

			printf("n101 = %d\n", n101);
			printf("n102 = %d\n", n102);
			printf("n103 = %d\n", n103);
			printf("n104 = %d\n", n104);
			printf("n105 = %d\n", n105);
			printf("n106 = %d\n", n106);
			printf("n107 = %d\n", n107);*/

		//deleting local variables
		delete[] d1;
		delete[] d2;
		delete[] d3;
		delete[] tens1;
		delete[] tens2;
		delete[] tens3;

		return ret_val;

	} /* stap */


}
